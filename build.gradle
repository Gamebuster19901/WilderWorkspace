plugins {
    id 'java-gradle-plugin'
    id 'eclipse'
    id 'maven-publish'
}

repositories {
    mavenCentral()
    maven {
        url "https://maven.fabricmc.net/"
    }
    maven {
    	url "https://maven.wildermods.com/"
    }
}

version = workspaceVersion
group = "com.wildermods"
archivesBaseName = "wilderworkspace"

sourceCompatibility = '17'
targetCompatibility = '17'

dependencies {
	gradleApi()
    implementation group: 'org.apache.commons', name: 'commons-lang3', version: commonsLangVersion
    implementation group: 'org.apache.commons', name: 'commons-text', version: commonsTextVersion
    implementation group: 'commons-io', name: 'commons-io', version: commonsIOVersion
    implementation group: 'net.fabricmc', name: 'fabric-loom', version: loomVersion
    implementation group: 'org.vineflower', name: 'vineflower', version: vineFlowerVersion
    implementation group: 'com.google.code.gson', name: 'gson', version: gsonVersion
}

import org.apache.tools.ant.filters.ReplaceTokens

task processSource(type: Sync) {
    from sourceSets.main.java.srcDirs
    into "$buildDir/processedSrc"
    
    //The version of the WilderWorkspace gradle plugin
    inputs.property 'workspaceVersion', workspaceVersion
    
    inputs.property 'accessWidenerVersion', accessWidenerVersion
    inputs.property 'tinyMappingsVersion', tinyMappingsVersion
    inputs.property 'mixinVersion', mixinVersion
    inputs.property 'guavaVersion', guavaVersion
    inputs.property 'gsonVersion', gsonVersion
    inputs.property 'providerVersion', providerVersion
    inputs.property 'asmVersion', asmVersion
    inputs.property 'fabricLoaderVersion', fabricLoaderVersion
    
    //dependencies for building and running WilderWorkspace gradle plugin itself
    inputs.property 'commonsIOVersion', commonsIOVersion
    inputs.property 'commonsLangVersion', commonsLangVersion
    inputs.property 'commonsTextVersion', commonsTextVersion
    inputs.property 'vineFlowerVersion', vineFlowerVersion
    inputs.property 'loomVersion', loomVersion
    
    //transitive dependencies
    inputs.property 'log4jVersion', log4jVersion
    
    filter(ReplaceTokens, tokens: [
        //The version of the WilderWorkspace gradle plugin
        workspaceVersion: workspaceVersion, 
        
        //dependencies that projects using WilderWorkspace will need in order to mod Wildermyth
        accessWidenerVersion: accessWidenerVersion,
        tinyMappingsVersion: tinyMappingsVersion,
        mixinVersion: mixinVersion,
        guavaVersion: guavaVersion,
        gsonVersion: gsonVersion,
        providerVersion: providerVersion,
        asmVersion: asmVersion,
        fabricLoaderVersion: fabricLoaderVersion,
        
        //dependencies for building and running WilderWorkspace gradle plugin itself
        commonsIOVersion: commonsIOVersion,
        commonsLangVersion: commonsLangVersion,
        commonsTextVersion: commonsTextVersion,
        vineFlowerVersion: vineFlowerVersion,
        loomVersion: loomVersion,
        
        //transitive dependencies
        log4jVersion: log4jVersion
    ])
}

compileJava {
    source = fileTree(dir: "$buildDir/processedSrc", include: '**/*.java')
    dependsOn processSource
}

ext.mavenLocalUrl = repositories.mavenLocal().url.toString()

task sourceJar(type: Jar) {
    from sourceSets.main.allSource
    archiveClassifier.set('sources')
}

tasks.register('checkArtifactExists') {
    doLast {
        def repoUrl = project.hasProperty('mavenRepoUrl') ? project.mavenRepoUrl : mavenLocalUrl
        def artifactPath = "${repoUrl}/${project.group.replace('.', '/')}/${project.archivesBaseName}/${project.version}/${project.archivesBaseName}-${project.version}.jar"
        logger.lifecycle("Checking if artifact exists at: $artifactPath")
        
        if (artifactPath.startsWith('file:/')) {
            // Handle file URLs
            def file = new File(new URI(artifactPath))
            if (file.exists()) {
                throw new IllegalStateException("Artifact '${project.group}:${project.archivesBaseName}:${project.version}' already exists. Publishing aborted.")
            }
        } else {
            // Handle HTTP URLs
            def url = new URL(artifactPath)
            def connection = url.openConnection()
            connection.setRequestMethod('HEAD')
            if (connection.responseCode == 200) {
				throw new IllegalStateException("Artifact '${project.group}:${project.archivesBaseName}:${project.version}' already exists. Publishing aborted.")
            }
        }
        logger.lifecycle("Artifact does not exist, proceeding with publish.")
    }
}

tasks.named('publish') {
    dependsOn 'checkArtifactExists'
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            groupId = project.group
            artifactId = project.archivesBaseName
            version = project.version

            // Attach sources JAR to the publication
            artifact sourceJar
        }
    }

    repositories {
        maven {
            url = uri(project.hasProperty('mavenRepoUrl') ? project.mavenRepoUrl : mavenLocalUrl) // Default to mavenLocal if no custom URL is provided
        }
    }
}
